Name

    ARB_debug_group

Name Strings

    GL_ARB_debug_group

Contact

    Christophe Riccio, AMD (christophe.riccio 'at' amd.com)

Contributors

    Seth Sowerby, Apple
    Benj Lipchak, Apple
    Georg Kolling, Imagination Technologies 
    Bruce Merry
    Daniel Rakos, AMD
    Jon Leech
    Piers Daniell, NVIDIA

Status

    Complete.
    Approved by the ARB on 2012/06/12.

Version

    Last Modified Date: June 14, 2012
    Revision: 11

Number

    ARB Extension #124

Dependencies

    OpenGL 1.1 and ARB_debug_output are required.

    This extension is written against the OpenGL 4.2 specification and 
    ARB_debug_output extension.

Overview

    This extension defines a mechanism for the OpenGL application to annotate 
    the command stream with markers for discrete events and groups of commands 
    using descriptive text. 
    
    When profiling or debugging an OpenGL application with a built-in or an 
    external debugger or profiler, it is difficult to relate the commands 
    within the command stream to the elements of the scene or parts of the 
    program code to which they correspond. Debug markers and debug groups help
    obviate this by allowing applications to specify this link. For example,
    a debug marker can be used to identify the beginning of a frame in the
    command stream and a debug group can encapsulate a specific command stream
    to identify a rendering pass. Debug groups also allow to control the debug 
    output volume per section of an application code providing an effective 
    way to handle the massive amount of debug outputs that drivers can 
    generate.
    
    The intended purpose of this is purely to improve the user experience 
    within OpenGL development tools and application built-in code for 
    debugging and profiling.

    This extension is based on the functionality proposed by the OpenGL ES 
    extension EXT_debug_marker but with a similar approach to ARB_debug_output
    for the purpose of synergy between APIs and debug functionalities. This 
    allows sharing a single set of APIs for both built-in and external 
    debuggers and profilers.

    Finally, this extension adds a new severity level (a notification) to 
    emphasise the profiling usages of the debug output functionality. It aims 
    reporting messages which are only useful notifications for the application
    perspective.

New Procedures and Functions

    void PushDebugGroup(enum source, uint id, sizei length, 
        const char * message);

    void PopDebugGroup();

New Tokens

    Tokens accepted or provided by the <type> parameters of
    DebugMessageControl, DebugMessageInsertand DEBUGPROC,
    and the <types> parameter of GetDebugMessageLog:

        DEBUG_TYPE_MARKER                           0x8268  

    Tokens accepted or provided by the <type> parameters of
    DebugMessageControl and DEBUGPROC, and the <types> parameter of 
    GetDebugMessageLog:

        DEBUG_TYPE_PUSH_GROUP                       0x8269  
        DEBUG_TYPE_POP_GROUP                        0x826A  

    Tokens accepted or provided by the <severity> parameters of
    DebugMessageControl, DebugMessageInsert and DEBUGPROC
    callback functions, and the <severities> parameter of
    GetDebugMessageLog:

        DEBUG_SEVERITY_NOTIFICATION                 0x826B  

    Accepted by the <pname> parameter of GetBooleanv, GetIntegerv,
    GetFloatv, GetDoublev, and GetInteger64v:
        
        MAX_DEBUG_GROUP_STACK_DEPTH                 0x826C  
        DEBUG_GROUP_STACK_DEPTH                     0x826D  

    Returned by GetError:

        STACK_UNDERFLOW                                 0x0504
        STACK_OVERFLOW                                  0x0503

Additions to Chapter 2 of the OpenGL 4.2 (Core Profile) Specification
(OpenGL Operation)

    None.

Additions to Chapter 3 of the OpenGL 4.2 (Core Profile) Specification
(Rasterization)

    None.

Additions to Chapter 4 of the OpenGL 4.2 (Core Profile) Specification
(Per-Fragment Operations and the Frame Buffer)

    None.

Additions to Chapter 5 of the OpenGL 4.2 (Core Profile) Specification
(Special Functions)

    In section 5.5 - Debug Output, add in table 5.4:

    DEBUG_TYPE_MARKER                     Annotation of the command stream 
    DEBUG_TYPE_PUSH_GROUP                 Entering a debug group
    DEBUG_TYPE_POP_GROUP                  Leaving a debug group

    In section 5.5 - Debug Output, add in table 5.5:

    DEBUG_SEVERITY_NOTIFICATION           Any message which is not an 
                                              error or performance concern 

    In section 5.5.4 - Controlling Debug Messages, replace:
    
    "Applications can control the volume of debug output by disabling
    specific or groups of messages with the command:"

    by:
        
    "Applications can control the volume of debug output in the active debug 
    group, by disabling specific or groups of messages with the command:"


    After section 5.5.5 - Externally Generated Messages, add new section:

    "5.5.6 - Debug Groups
    
    Debug groups provide a method for annotating a command stream with discrete 
    groups of commands using a descriptive text. Debug output messages, either 
    generated by the implementation or inserted by the application with 
    DebugMessageInsert are written to the active debug group, the top of 
    the debug group stack. Debug groups are strictly hierarchical. Their 
    sequences may be nested within other debug groups but can not overlap. If 
    no debug group has been pushed by the application then the active debug 
    group is the default debug group. 
    
    The command
    
        void PushDebugGroup(enum source, uint id, sizei length, 
            const char *message);
        
    pushes a debug group described by the string <message> into the
    command stream. The value of <id> specifies the ID of messages 
    generated. The parameter <length> contains the number of characters 
    in <message>. If <length> is negative, it is implied that <message>
    contains a null terminated string. The message has the specified <source> 
    and <id>, <type> DEBUG_TYPE_PUSH_GROUP, and <severity>
    DEBUG_SEVERITY_NOTIFICATION. The GL will put a new debug group
    on top of the debug group stack which inherits the control of the
    volume of debug output of the debug group previously residing on the
    top of the debug group stack. Because debug groups are strictly
    hierarchical, any additional control of the debug output volume will
    only apply within the active debug group and the debug groups pushed
    on top of the active debug group.

    An INVALID_ENUM error is generated if the value of <source> is
    neither DEBUG_SOURCE_APPLICATION nor
    DEBUG_SOURCE_THIRD_PARTY. An INVALID_VALUE error is generated 
    if <length> is negative and the number of characters in <message>,
    excluding the null-terminator, is not less than the value of
    MAX_DEBUG_MESSAGE_LENGTH.
        
    The command
    
        void PopDebugGroup();
        
    pops the active debug group. After popping a debug group, the GL will 
    also generate a debug output message describing its cause based on the 
    <message> string, the source <source>, and an ID <id> submitted to the 
    associated PushDebugGroup command. DEBUG_TYPE_PUSH_GROUP and
    DEBUG_TYPE_POP_GROUP share a single namespace for message <id>.
    <severity> has the value DEBUG_SEVERITY_NOTIFICATION. The <type> 
    has the value DEBUG_TYPE_POP_GROUP. Popping a debug group restores 
    the debug output volume control of the parent debug group.

    Attempting to pop the default debug group off the stack generates a
    STACK_UNDERFLOW error; pushing a debug group onto a stack containing
    MAX_DEBUG_GROUP_STACK_DEPTH minus one elements will generate a 
    STACK_OVERFLOW error."

Additions to Chapter 6 of the OpenGL 4.2 (Core Profile) Specification
(State and State Requests)

    None.

Errors

    The error INVALID_ENUM will be generated by PushDebugGroup
    if <source> is not DEBUG_SOURCE_APPLICATION or 
    DEBUG_SOURCE_THIRD_PARTY. 

    The error INVALID_VALUE will be generated by PushDebugGroup
    if <length> is negative and the number of characters in <message>,
    excluding the null-terminator, is not less than the value of
    MAX_DEBUG_MESSAGE_LENGTH.

    The <source> value of PushDebugGroup must be either 
    DEBUG_SOURCE_APPLICATION or DEBUG_SOURCE_THIRD_PARTY, or the
    error INVALID_ENUM will be generated.

    Popping a group off the stack with no entry generates the error 
    STACK_UNDERFLOW; pushing a debug group onto a full stack generates 
    the error STACK_OVERFLOW.

New State

                                                    Initial
    Get Value                    Type  Get Command  Value    Description        Section  
    ---------------------------  ----  -----------  -------  -----------------  -------
    DEBUG_GROUP_STACK_DEPTH  Z+    GetIntegerv  1        Debug group stack  5.5.6
                                                             pointer    


New Implementation Dependent State                                                       

                                                        Minimum
    Get Value                        Type  Get Command  Value    Description    Section  
    -------------------------------  ----  -----------  -------  -------------  -------
    MAX_DEBUG_GROUP_STACK_DEPTH  Z+    GetIntegerv  64       Maximum group  5.5.6
                                                                 stack depth 
 
Modifications to The OpenGL Shading Language Specification, Version 4.20.8

    None.

Conformance Tests

    <TBD>

Usage Examples

Scenario 1: skip a section of the code
// Setup of the default active debug group: Filter everything in
glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, NULL, GL_TRUE);

// Generate a debug marker debug output message
glDebugMessageInsert(
    GL_DEBUG_SOURCE_APPLICATION, 
    GL_DEBUG_TYPE_MARKER, 100,
    GL_DEBUG_SEVERITY_NOTIFICATION, 
    -1, "Message 1");
    
// Push debug group 1
glPushDebugGroup(
    GL_DEBUG_SOURCE_APPLICATION, 
    1, 
    -1, "Message 2");
 
// Setup of the debug group 1: Filter everything out
glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, NULL, GL_FALSE);

// This message won't appear in the debug output log of 
glDebugMessageInsert(
    GL_DEBUG_SOURCE_APPLICATION, 
    GL_DEBUG_TYPE_MARKER, 100,
    GL_DEBUG_SEVERITY_NOTIFICATION, 
    -1, "Message 3"); 
 
// Pop debug group 1, restaure the volume control of the default debug group.
glPopDebugGroup();
 
// Generate a debug marker debug output message
glDebugMessageInsert(
    GL_DEBUG_SOURCE_APPLICATION, 
    GL_DEBUG_TYPE_MARKER, 100,
    GL_DEBUG_SEVERITY_NOTIFICATION, 
    -1, "Message 5");

// A possible debug output
Group depth 0 - GL_DEBUG_TYPE_MARKER - Message 1 
Group depth 0 - GL_DEBUG_TYPE_PUSH_GROUP - Message 2
Group depth 0 - GL_DEBUG_TYPE_POP_GROUP - Message 2
Group depth 0 - GL_DEBUG_TYPE_MARKER - Message 5

Scenario 2: Only output a subsection of the code 
and disable some messages for the entire application

// Setup the control of de debug output for the default debug group 
glDebugMessageControl(
    GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, NULL, GL_FALSE);
glDebugMessageControl(
    GL_DEBUG_SOURCE_THIRD_PARTY, GL_DONT_CARE, GL_DONT_CARE, 0, NULL, GL_FALSE);
std::vector<GLuint> Messages = {1234, 2345, 3456, 4567};
glDebugMessageControl(
    GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_OTHER, GL_DONT_CARE, 
    GLuint(Messages,size()), &Messages[0], GL_FALSE);
glDebugMessageControl(
    GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_PORTABILITY, GL_DONT_CARE, 
    GLuint(Messages,size()), &Messages[0], GL_FALSE);

// Push debug group 1
// Inheritate of the default debug group debug output volume control
// Filtered out by glDebugMessageControl
glPushDebugGroup(
    GL_DEBUG_SOURCE_APPLICATION, 
    1,
    -1, "Message 1"); 
    
// In this section of the code, we are interested in performances.
glDebugMessageControl(
    GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_PERFORMANCE, GL_DONT_CARE, 0, NULL, GL_TRUE);
// But we already identify that some messages are not really useful for us.
std::vector<GLuint> Messages = {5678, 6789};
glDebugMessageControl(
    GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_OTHER, GL_DONT_CARE, 
    GLuint(Messages,size()), &Messages[0], GL_FALSE);

glDebugMessageInsert(
    GL_DEBUG_SOURCE_APPLICATION, 
    GL_DEBUG_TYPE_PERFORMANCE, 1357,
    GL_DEBUG_SEVERITY_MEDIUM, 
    -1, "Message 2"); 
glDebugMessageInsert(
    GL_DEBUG_SOURCE_THIRD_PARTY, // We still filter out these messages.
    GL_DEBUG_TYPE_OTHER, 3579,
    GL_DEBUG_SEVERITY_MEDIUM, 
    -1, "Message 3"); 
    
glPopDebugGroup(); 

// A possible debug output
Group depth 1 - GL_DEBUG_TYPE_OTHER - Message 2


Issues

    (0) What this extension should be called?

    RESOLVED: GL_debug_group. Even if it takes the features of 
              the OpenGL ES extension EXT_debug_marker, it is 
              written considering the interaction with ARB_debug_output.
              Hence, the group prefer to give it a different name. As 
              at least 80% of the language focus on debug group rather
              than marker, we choose GL_debug_group.


    (1) Should the extension provides a method for querying markers?

    RESOLVED: No, this extension depends on and interacts with 
              ARB_debug_output which provides all the necessary 
              infrastructure already.


    (2) Is the concept of <severity> meaningful for most profiling use cases?
    
    DISCUSSION: The debug output API was originally designed for debugging 
                but its design has led implementation and application to use 
                it for profiling. Furthermore, markers are not strictly 
                speaking low, medium or high severity messages.
    
    RESOLVED: Added DEBUG_SEVERITY_NOTIFICATION


    (3) How should an implementation behave when the application doesn't push 
        and pop group markers evenly?
    
    DISCUSSION: Extra "pop" may be ignored as it is done in OpenGL ES 
                EXT_debug_marker but what to do if the user push too many 
                time? In any case, if a software doesn't push and pop evenly, 
                its design is pretty ill. Hence it is better to notify the 
                application as soon as possible by generating an error.

                OpenGL legacy handles this problem by limiting the size of the 
                stacks and generating STACK_UNDERFLOW and STACK_OVERFLOW 
                errors. 

                The size of the marker group stack need to be big enough so 
                that the application won't be limited but small enough so that 
                an error is generated soon when pushes and pops are not even.
    
                Another option is to let the drivers workaround this issue by
                ignoring push commands for a full stack and pop commands for 
                an empty stack. In such case, an application doesn't have an 
                immediate feedback for this behavior. 

    RESOLVED: Generates STACK_UNDERFLOW or STACK_UNDERFLOW errors 


    (4) Do we need a maximum length for a marker string?

    RESOLVED: No, reuse MAX_DEBUG_MESSAGE_LENGTH

    
    (5) Can we use this new extension to allow applications to request the 
        info logs from compiling, linking and validating to be automatically 
        submitted to the debug output log and debug output call-back function? 

    DISCUSSION: The API may need a new <type> value DEBUG_TYPE_INFO_LOG 
                for every kind of info logs. glLinkProgram, glCompileShader, 
                glCreateShaderProgram, glValidateProgram and 
                glValidateProgramPipeline,  which execution generate the info 
                logs, could also automatically submit this logs the the debug
                output API.

                Such strategy can already be apply by querying the info log 
                manually and submitting it to the debug output API with 
                DebugMessageInsert but on some implementations querying the 
                log immediately after the operation may significantly slow 
                down the general compilation of shaders process. 

                The mechanism could be enable with glEnable with a dedicated 
                value (DEBUG_OUTPUT_INFO_LOG). When enable, an option is 
                that shader, program and program pipeline would not have to 
                maintain this log.

                This perspective emphasis the centralised nature of OpenGL
                debugging to the debug output API. 

    RESOLVED: Nothing prevent an implementation implementing ARB_debug_output
              to do it already.  


    (6) Should we use dedicated functions for pushing and popping the group 
        marker stack or use DebugMessageInsert with a dedicated types?

    DISCUSSION: These functions have side effects (causing underflow errors, 
                causing other messages to become disabled) rather than purely 
                injecting messages into the debug log.

    RESOLVED: Use separated functions.


    (7) Should we generate an error when we pop the last entry or when the 
        stack is empty?

    DISCUSSION: For the deprecated stacks, at the beginning of the program the 
                stack depth was 1 which implies a default debug group (id 0?) 
                in the present case. 

    RESOLVED: Let's follow the deprecated stacks precedent.
    

    (8) Should we be able to query the current debug group?

    DISCUSSION: ARB_debug_output doesn't provide a query API for debug output 
                control states, should we follow this precedent or are there 
                use cases where is could be especially useful?

    RESOLVED: No, it doesn't seem very useful.


    (9) Should we provide within which debug group a message is generated?

    DISCUSSION: Such information might be useful but we would need to add a 
                parameter to the callback function. Also, the application can 
                take the responsibility of saving the current active debug
                group. Such option avoid API disruption.

    RESOLVED: (8) could resolve this issue as well if this is actually at 
              desired feature. Also nothing prevents an implementation to use 
              a debug group id to form the debug output message. Finally an 
              application can always store the current debug group each time 
              a DEBUG_TYPE_PUSH_GROUP is generated.

    
    (10) Do we need a dedicated mechanism to enable and disable debug outputs?

    DISCUSSION: It could seem that using glDebugMessageControl could allow 
                to disable debug output. However with the introduction of 
                debug groups, glDebugMessageControl only disable the active 
                debug group and it could be pretty complex for an application 
                to ensure that each debug group is disable. A easier idea 
                would be to be global switch glEnable(GL_DEBUG_OUTPUT) 
                allowing the application to completely switch on and off the 
                entire debug output mechanism.

    RESOLVED: Issue covered by ARB_debug_output2

Revision History

    Revision 11, 2012/06/14 (Jon Leech)
      - Remove remaining ARB suffixes.

    Revision 10, 2012/06/12 (criccio)
      - Clarify when the message is generated by the GL when popping
        a debug group.

    Revision 9, 2012/05/16 (criccio)
      - Added Jon's feedback.
      - Un-reserved <id> message 0 for debug group type
      - Clarify that DEBUG_TYPE_PUSH_GROUP and 
        DEBUG_TYPE_POP_GROUP share the same <id> namespace
      - Clarify PushDebugGroup description

    Revision 8, 2012/05/15 (Jon Leech)
      - Fix an error condition for PushDebugGroup and slightly rewrite
        errors for consistency with core spec language.

    Revision 7, 2012/04/26 (criccio)
      - Renamed to ARB_debug_group

    Revision 6, 2012/04/16 (criccio)
      - Clarified when a STACK_OVERFLOW error is generated
      - Removed MAX_DEBUG_MARKER_LENGTH
      - Typos 

    Revision 5, 2012/03/15 (criccio)
      - Clarify debug group and debug marker
      - Added DEBUG_GROUP_STACK_DEPTH
      - Allowed empty null terminated strings for markers
      - Resolved issue 5 and 6
      - Fixed alignments
      - Added issue 8, 9 and 10
      - Added use samples

    Revision 4, 2012/01/11 (criccio)
      - Added issue (7)

    Revision 3, 2012/01/09 (criccio)
      - Added back STACK_UNDERFLOW and STACK_OVERFLOW values
      - Clarified issue (5)

    Revision 2, 2012/01/06 (criccio)
      - Clarified debug output message generated by PushGroupMarker and 
        PopGroupMarker 
      - Fixed some typos
      - Added stack overflow and underflow errors
      - Added interactions of the group markers with DebugMessageControl 
      - Added issue (5)
      - Added issue (6)

    Revision 1, 2012/01/04 (criccio)
      - First draft
